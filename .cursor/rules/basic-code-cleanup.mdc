---
alwaysApply: false
---
# Code Cleanup and Refactoring Rules for TypeScript Projects

## Overview
This guide explains systematic code cleanup procedures focusing on refactoring patterns, removing magic values, proper documentation, type safety, and common code smells. Follow these rules to improve code maintainability, readability, and testability.

---

## 1. Core Refactoring Patterns

### Template Method Pattern

**When to use:** When multiple subclasses have similar methods with duplicate logic, but different values (like prompts).

**Principle:** Extract common logic into a template method in the base class. Subclasses provide only unique values and delegate execution.

**Before - Duplicate code in subclasses:**
```typescript
// ArchitectAgent
async propose(problem: string, context: DebateContext): Promise<Proposal> {
  const system = this.config.systemPrompt || ARCHITECT_SYSTEM_PROMPT;
  const user = `Problem: ${problem}\n\nProvide architectural solution...`;
  const { text, usage, latencyMs } = await this.callLLM(system, user);
  const metadata: ContributionMetadata = { latencyMs, model: this.config.model };
  if (usage?.totalTokens != null) metadata.tokensUsed = usage.totalTokens;
  return { content: text, metadata };
}

// PerformanceAgent - SAME LOGIC, different prompts
async propose(problem: string, context: DebateContext): Promise<Proposal> {
  const system = this.config.systemPrompt || PERFORMANCE_SYSTEM_PROMPT;
  const user = `Problem: ${problem}\n\nProvide performance solution...`;
  const { text, usage, latencyMs } = await this.callLLM(system, user);
  const metadata: ContributionMetadata = { latencyMs, model: this.config.model };
  if (usage?.totalTokens != null) metadata.tokensUsed = usage.totalTokens;
  return { content: text, metadata };
}
```

**After - Template method in base class:**
```typescript
// Base Agent class
/**
 * Template method for generating proposals.
 * Subclasses should call this method from their `propose` implementation after preparing prompts.
 *
 * @final
 * @param _context - The current debate context (unused in base implementation).
 * @param systemPrompt - The system prompt to use for the LLM.
 * @param userPrompt - The user prompt to use for the LLM.
 * @returns A Promise resolving to a Proposal object containing the agent's solution and metadata.
 */
protected async proposeImpl(
  _context: DebateContext,
  systemPrompt: string,
  userPrompt: string
): Promise<Proposal> {
  const { text, usage, latencyMs } = await this.callLLM(systemPrompt, userPrompt);
  const metadata: ContributionMetadata = { latencyMs, model: this.config.model };
  if (usage?.totalTokens != null) metadata.tokensUsed = usage.totalTokens;
  return { content: text, metadata };
}

// ArchitectAgent - only prompts, no duplicate logic
async propose(problem: string, context: DebateContext): Promise<Proposal> {
  const system = this.config.systemPrompt || ARCHITECT_SYSTEM_PROMPT;
  const user = `Problem: ${problem}\n\nProvide architectural solution...`;
  return this.proposeImpl(context, system, user);
}

// PerformanceAgent - clean and simple
async propose(problem: string, context: DebateContext): Promise<Proposal> {
  const system = this.config.systemPrompt || PERFORMANCE_SYSTEM_PROMPT;
  const user = `Problem: ${problem}\n\nProvide performance solution...`;
  return this.proposeImpl(context, system, user);
}
```

**Benefits:**
- ✅ **No code duplication** - Common logic exists in one place
- ✅ **Easy to maintain** - Fix bugs once, applies to all subclasses
- ✅ **Clear separation** - Subclasses focus on their unique concerns
- ✅ **Consistent behavior** - All agents handle metadata the same way

### General Pattern Extraction

**When to use:** The same logic pattern is repeated 3+ times, even if not in a class hierarchy.

**Example - Repeated pattern:**
```typescript
// ❌ BAD: Same 18-line pattern repeated 3 times
function buildAgents() {
  return configs.map((cfg) => {
    if (cfg.role === ARCHITECT) {
      const defaultText = ArchitectAgent.defaultSystemPrompt();
      const res = resolvePrompt({ label: cfg.name, configDir, defaultText });
      const agent = ArchitectAgent.create(cfg, provider, res.text, 
        res.source === 'file' ? { source: 'file', absPath: res.absPath } : { source: 'built-in' }
      );
      collect.agents.push({ agentId: cfg.id, role: cfg.role, source: res.source });
      return agent;
    }
    if (cfg.role === PERFORMANCE) {
      // ... exact same 18 lines with different class name
    }
    // ... same pattern again for default case
  });
}
```

**Solution - Extract to helper function:**
```typescript
// ✅ GOOD: Extract to helper function
function createAgentWithPromptResolution(
  agentClass: typeof ArchitectAgent | typeof PerformanceAgent,
  cfg: AgentConfig,
  provider: OpenAIProvider,
  configDir: string,
  collect: { agents: AgentPromptMetadata[] }
): Agent {
  const defaultText = agentClass.defaultSystemPrompt();
  const res = resolvePrompt({ label: cfg.name, configDir, defaultText });
  
  const promptSource: PromptSource = res.source === PROMPT_SOURCES.FILE
    ? { source: PROMPT_SOURCES.FILE, absPath: res.absPath }
    : { source: PROMPT_SOURCES.BUILT_IN };
  
  const agent = agentClass.create(cfg, provider, res.text, promptSource);
  collect.agents.push({ agentId: cfg.id, role: cfg.role, source: res.source });
  
  return agent;
}

// Usage: Clean and simple
function buildAgents() {
  return configs.map((cfg) => {
    if (cfg.role === ARCHITECT) {
      return createAgentWithPromptResolution(ArchitectAgent, cfg, provider, configDir, collect);
    }
    if (cfg.role === PERFORMANCE) {
      return createAgentWithPromptResolution(PerformanceAgent, cfg, provider, configDir, collect);
    }
    warnUser(`Unknown role '${cfg.role}'. Defaulting to architect.`);
    return createAgentWithPromptResolution(ArchitectAgent, cfg, provider, configDir, collect);
  });
}
```

---

## 2. Constants and Magic Values

### What are Magic Values?
Magic numbers/strings are literal values hardcoded in your code without explanation. They make code harder to understand and maintain.

### Removing Magic Numbers

**Bad - Magic numbers:**
```typescript
const debateConfig = {
  rounds: options.rounds || config.rounds || 3,  // What is 3?
  timeout: 300000  // What is 300000?
};
```

**Good - Named constants:**
```typescript
const DEFAULT_ROUNDS = 3;
const DEFAULT_TIMEOUT_MS = 300000;

const debateConfig = {
  rounds: options.rounds || config.rounds || DEFAULT_ROUNDS,
  timeout: DEFAULT_TIMEOUT_MS
};
```

### Removing Magic Strings

**Bad - Hardcoded strings:**
```typescript
function buildAgents(configs: AgentConfig[], provider: Provider) {
  return configs.map((cfg) => {
    if (cfg.role === 'architect') return new ArchitectAgent(cfg, provider);
    if (cfg.role === 'performance') return new PerformanceAgent(cfg, provider);
    return new ArchitectAgent(cfg, provider);
  });
}

process.stderr.write(color('yellow', 'Warning message') + '\n');
console.log(color('gray', 'Debug info'));
```

**Good - Named constants:**
```typescript
export const AGENT_ROLES = {
  ARCHITECT: "architect",
  SECURITY: "security",
  PERFORMANCE: "performance",
  TESTING: "testing",
  GENERALIST: "generalist",
} as const;

export type AgentRole = (typeof AGENT_ROLES)[keyof typeof AGENT_ROLES];

export const WARNING_COLOR = 'yellow';
export const INFO_COLOR = 'gray';

// Now the code is self-documenting
function buildAgents(configs: AgentConfig[], provider: Provider) {
  return configs.map((cfg) => {
    if (cfg.role === AGENT_ROLES.ARCHITECT) return new ArchitectAgent(cfg, provider);
    if (cfg.role === AGENT_ROLES.PERFORMANCE) return new PerformanceAgent(cfg, provider);
    return new ArchitectAgent(cfg, provider);
  });
}

process.stderr.write(color(WARNING_COLOR, 'Warning message') + '\n');
console.log(color(INFO_COLOR, 'Debug info'));
```

**Even Better - Encapsulate behavior:**
```typescript
export function warnUser(message: string): void {
  process.stderr.write(color(WARNING_COLOR, message) + '\n');
}

// Usage
warnUser('Warning message');
```

### Where to Define Constants

**Function-level constants** - Use when a value is used multiple times within a single function:
```typescript
it('should write JSON output when --output ends with .json', async () => {
  const EXPECTED_REASONING = 'Good';
  const outputPath = path.join(tmpDir, 'results.json');
  
  // Use EXPECTED_REASONING in mock data and assertion
  evalSpy.mockResolvedValueOnce({
    rawText: JSON.stringify({
      evaluation: { functional_completeness: { score: 8, reasoning: EXPECTED_REASONING } }
    })
  });
  
  expect(content.agents.e1.evaluation.functional_completeness.reasoning).toBe(EXPECTED_REASONING);
});
```

**File-level constants** - Use when only one file needs them:
```typescript
// At top of file, after imports
const DEFAULT_ROUNDS = 3;
const MAX_RETRIES = 5;
```

**Exported constants** - Use when multiple files need them:
```typescript
// In types/constants file
export const AGENT_ROLES = {
  ARCHITECT: "architect",
  PERFORMANCE: "performance",
} as const;

export const LLM_PROVIDERS = {
  OPENAI: "openai",
} as const;
```

**Benefits:**
- ✅ **Self-documenting** - Name explains what the value means
- ✅ **Single source of truth** - Change value in one place
- ✅ **Type safety** - TypeScript can help catch errors
- ✅ **Easier to find** - Search for constant name, not a number
- ✅ **Consistency** - All usages use the same value
- ✅ **Maintainability** - Change value in one place

---

## 3. Documentation Standards

### JSDoc Comments

Every public function, class, and complex method should have JSDoc documentation.

**Template for functions:**
```typescript
/**
 * Brief one-line description of what the function does.
 * 
 * Optional longer description explaining the function's behavior,
 * edge cases, or important details.
 *
 * @param paramName - Description of the parameter.
 * @param options - Command-line options containing optional settings.
 * @returns Description of what the function returns.
 * @throws {ErrorType} When and why this error is thrown.
 */
function myFunction(paramName: string, options: any): ReturnType {
  // implementation
}
```

**Example - Well-documented function:**
```typescript
/**
 * Creates a DebateConfig from the system configuration and command-line options.
 * Validates that the number of rounds is at least 1.
 *
 * @param sysConfig - The system configuration.
 * @param options - Command-line options containing optional rounds override.
 * @returns The debate configuration.
 * @throws {Error} If rounds is less than 1.
 */
function debateConfigFromSysConfig(sysConfig: SystemConfig, options: any): DebateConfig {
  const debateCfg: DebateConfig = {
    ...sysConfig.debate!,
    rounds: options.rounds ? parseInt(options.rounds, 10) : (sysConfig.debate?.rounds ?? DEFAULT_ROUNDS),
  } as DebateConfig;
  
  if (!debateCfg.rounds || debateCfg.rounds < 1) {
    const err: any = new Error('Invalid arguments: --rounds must be >= 1');
    err.code = EXIT_INVALID_ARGS;
    throw err;
  }
  
  return debateCfg;
}
```

### Special Tags

**@final** - Indicates a method should not be overridden:
```typescript
/**
 * Template method for generating proposals.
 * 
 * @final
 * @param systemPrompt - The system prompt to use for the LLM.
 * @param userPrompt - The user prompt to use for the LLM.
 * @returns A Promise resolving to a Proposal.
 */
protected async proposeImpl(systemPrompt: string, userPrompt: string): Promise<Proposal> {
  // implementation
}
```

### Inline Comments for Non-Obvious Choices

When you make a non-obvious technical choice, explain why:
```typescript
// Use process.stderr.write for immediate, unbuffered output with precise newline control (CLI best practice)
process.stderr.write(color('yellow', 'Config missing agents. Using built-in defaults.') + '\n');

// NOT console.error() because:
// - process.stderr.write gives precise control over newlines
// - It's unbuffered for immediate output
// - Standard practice for professional CLI tools
```

### What NOT to document

Don't document obvious things:
```typescript
// ❌ BAD - Obvious from code
// Increment counter by one
counter++;

// ✅ GOOD - Explains WHY
// Skip first element as it's the header row
for (let i = 1; i < rows.length; i++) {
  processRow(rows[i]);
}
```

---

## 4. Type Safety

### When to Use Type Assertions (`as Type`)

Type assertions should be used **sparingly** and only in specific scenarios where you have information that TypeScript cannot infer.

#### ✅ Valid Use Cases

**1. Working with Third-Party Libraries**
When dealing with `any` types from external libraries where you know the actual type:
```typescript
// Third-party library returns 'any'
const data = externalAPI.fetchData() as UserData;
```

**2. Type Narrowing After Runtime Validation**
When you've validated the type at runtime but TypeScript can't track it:
```typescript
function processData(data: unknown) {
  if (isValidUser(data)) {
    // We've validated it's a User, but TypeScript doesn't know
    const user = data as User;
    return user.name;
  }
}
```

**3. Complex Type Scenarios TypeScript Cannot Infer**
When working with advanced type transformations that are correct but TypeScript cannot prove:
```typescript
// Complex mapped type that TypeScript struggles with
const result = transformData(input) as TransformedType;
```

#### ❌ Invalid Use Cases

**1. Hiding Legitimate Type Errors**
**NEVER** use type assertions to bypass valid TypeScript errors:
```typescript
// ❌ BAD: Hiding a real type mismatch
const state: DebateState = {
  context: undefined,  // Type error!
} as DebateState;

// ✅ GOOD: Fix the actual issue
const state: DebateState = {
  ...(context !== undefined && { context }),
};
```

**2. Working Around Optional Properties**
**NEVER** use assertions to force undefined into optional properties:
```typescript
// ❌ BAD: Using assertion to hide strictness issue
const obj = { value: undefined } as MyType;

// ✅ GOOD: Conditionally include the property
const obj = { ...(value !== undefined && { value }) };

// ❌ BAD: Unnecessary cast for optional property deletion
async setPromptSources(sources: DebateState['promptSources']): Promise<void> {
  const state = this.debates.get(debateId);
  if (sources) {
    state.promptSources = sources;
  } else {
    delete (state as any).promptSources; // Unnecessary!
  }
}

// ✅ GOOD: Optional properties can be deleted without cast
async setPromptSources(sources: DebateState['promptSources']): Promise<void> {
  const state = this.debates.get(debateId);
  if (sources) {
    state.promptSources = sources;
  } else {
    delete state.promptSources; // Works fine!
  }
}
```

**3. Forcing Incompatible Types**
**NEVER** use assertions to force incompatible types:
```typescript
// ❌ BAD: These types are fundamentally incompatible
const num = "string" as number;

// ✅ GOOD: Convert properly
const num = parseInt("string", 10);

// ❌ BAD: Using 'as any' to bypass type mismatch
interface Contribution {
  agentId: string;
  agentRole: AgentRole;
  type: ContributionType;
  content: string;
  metadata: { tokensUsed?: number; latencyMs?: number };
}

interface Critique {
  content: string;
  metadata: { tokensUsed?: number; latencyMs?: number };
}

async refinementPhase() {
  const critiques = contributions.filter(c => c.type === 'critique');
  
  // Type error: Contribution[] is not Critique[]
  const refined = await agent.refine(original, critiques as any, ctx); // BAD!
}

// ✅ GOOD: Properly map types
async refinementPhase() {
  const critiqueContributions = contributions.filter(c => c.type === 'critique');
  
  // Map Contribution[] to Critique[] by extracting needed fields
  const critiques: Critique[] = critiqueContributions.map((c) => ({
    content: c.content,
    metadata: c.metadata
  }));
  
  const refined = await agent.refine(original, critiques, ctx); // Type-safe!
}
```

### Key Principle

> **Type assertions are for saying "trust me, I know better" — not "ignore this error."**

If you find yourself using `as` to silence an error, stop and ask:
1. Is this a real type incompatibility I should fix?
2. Can I narrow the type properly with guards or validation?
3. Am I hiding a bug that will surface at runtime?

### Alternative Solutions

Before using type assertions, consider:
- **Type guards**: `if (typeof x === 'string')`
- **Discriminated unions**: Use `type` fields to narrow types
- **Conditional spreads**: `...(value !== undefined && { value })`
- **Proper typing**: Fix the type definitions rather than casting
- **Validation libraries**: Use runtime validators like Zod or io-ts

---

## 5. Code Smells

This section provides guidelines for identifying and fixing common code smells with real examples.

### 5.1 Unnecessary Exports

**Problem:** Exporting constants or functions that are only used internally, creating unnecessary public API surface.

**Code Smell:**
```typescript
// ❌ BAD: Constant is exported but only method should be public
export const DEFAULT_PERFORMANCE_SYSTEM_PROMPT = `You are a performance engineer...`;

export class PerformanceAgent {
  static defaultSystemPrompt(): string { 
    return DEFAULT_PERFORMANCE_SYSTEM_PROMPT; 
  }
}

// Usage elsewhere
PerformanceAgent.defaultSystemPrompt(); // Only this is used
```

**Solution:**
```typescript
// ✅ GOOD: Keep constant private, expose through method
const DEFAULT_PERFORMANCE_SYSTEM_PROMPT = `You are a performance engineer...`;

export class PerformanceAgent {
  static defaultSystemPrompt(): string { 
    return DEFAULT_PERFORMANCE_SYSTEM_PROMPT; 
  }
}
```

**Why It Matters:**
- **Encapsulation**: Internal implementation details should not be part of the public API
- **Maintainability**: Changes to internal constants won't break external consumers
- **Single Source of Truth**: The static method is the intended public interface

### 5.2 Inline Type Definitions (DRY Violation)

**Problem:** Repeating the same inline type definition multiple times across the codebase.

**Code Smell:**
```typescript
// ❌ BAD: Same inline type repeated 8+ times
function createAgent(
  promptSource?: { source: 'built-in' | 'file'; absPath?: string }
) { }

class JudgeAgent {
  public readonly promptSource?: { source: 'built-in' | 'file'; absPath?: string };
  constructor(
    promptSource?: { source: 'built-in' | 'file'; absPath?: string }
  ) { }
}

// ... repeated 5+ more times
```

**Solution:**
```typescript
// ✅ GOOD: Define once, use everywhere
export interface PromptSource {
  source: 'built-in' | 'file';
  absPath?: string;
}

function createAgent(promptSource?: PromptSource) { }

class JudgeAgent {
  public readonly promptSource?: PromptSource;
  constructor(promptSource?: PromptSource) { }
}
```

**Why It Matters:**
- **DRY Principle**: Single source of truth for type definitions
- **Maintainability**: Changes only need to be made in one place
- **Documentation**: Named types are self-documenting
- **Reusability**: Can extend or compose types easily

### 5.3 Improper stdout/stderr Usage

**Problem:** Writing diagnostic/verbose output to stdout instead of stderr, breaking Unix pipeline conventions.

**Code Smell:**
```typescript
// ❌ BAD: Mixing diagnostic output with results on stdout
async function outputResults(result: DebateResult) {
  // Main result (should be stdout)
  process.stdout.write(result.solution.description);
  
  // Diagnostic info (should be stderr, but goes to stdout)
  if (options.verbose) {
    process.stdout.write('Running debate (verbose)\n');
    process.stdout.write('Active Agents:\n');
    rounds.forEach(round => {
      process.stdout.write(`Round ${round.number}\n`);
    });
  }
}

// Problem: Can't pipe results without getting verbose output
// $ debate "problem" > solution.txt  (verbose output pollutes file)
```

**Solution:**
```typescript
// ✅ GOOD: Proper separation
export function writeStderr(message: string): void {
  process.stderr.write(message);
}

async function outputResults(result: DebateResult) {
  // Main result on stdout (pipeable)
  process.stdout.write(result.solution.description);
  
  // Diagnostic info on stderr (doesn't interfere with piping)
  if (options.verbose) {
    writeStderr('Running debate (verbose)\n');
    writeStderr('Active Agents:\n');
    rounds.forEach(round => {
      writeStderr(`Round ${round.number}\n`);
    });
  }
}

// Now piping works correctly:
// $ debate "problem" > solution.txt  (only solution goes to file)
// $ debate "problem" 2>/dev/null     (suppress diagnostics)
```

**Why It Matters:**
- **Unix Philosophy**: stdout = data, stderr = diagnostics
- **Pipeable Output**: Results can be piped without noise
- **Standard Compliance**: Follows CLI best practices
- **User Experience**: Users can redirect output as expected

### 5.4 Redundant Function Calls

**Problem:** Calling the same function multiple times when the result could be reused.

**Code Smell:**
```typescript
// ❌ BAD: Function called up to 4 times
export async function loadConfig(configPath?: string): Promise<SystemConfig> {
  if (!fs.existsSync(finalPath)) {
    const defaults = builtInDefaults(); // Call 1
    return defaults;
  }
  
  const parsed = JSON.parse(raw);
  
  if (!Array.isArray(parsed.agents) || parsed.agents.length === 0) {
    const defaults = builtInDefaults(); // Call 2
    return defaults;
  }
  
  if (!parsed.judge) {
    parsed.judge = builtInDefaults().judge; // Call 3
  }
  
  if (!parsed.debate) {
    parsed.debate = builtInDefaults().debate; // Call 4
  }
  
  return parsed;
}
```

**Solution:**
```typescript
// ✅ GOOD: Call once, reuse everywhere
export async function loadConfig(configPath?: string): Promise<SystemConfig> {
  const defaults = builtInDefaults(); // Call once
  
  if (!fs.existsSync(finalPath)) {
    defaults.configDir = process.cwd();
    return defaults;
  }
  
  const parsed = JSON.parse(raw);
  
  if (!Array.isArray(parsed.agents) || parsed.agents.length === 0) {
    defaults.configDir = path.dirname(finalPath);
    return defaults;
  }
  
  if (!parsed.judge) {
    parsed.judge = defaults.judge; // Reuse
  }
  
  if (!parsed.debate) {
    parsed.debate = defaults.debate; // Reuse
  }
  
  return parsed;
}
```

**Why It Matters:**
- **Performance**: Avoid redundant computation
- **Efficiency**: Especially important if function is expensive
- **Clarity**: Shows defaults are the same throughout function
- **Maintainability**: Changes to default computation happen once

### 5.5 Complex Nested Logic

**Problem:** Deeply nested loops and conditionals that are hard to read and understand.

**Code Smell:**
```typescript
// ❌ BAD: 18+ lines of nested logic embedded in function
async function outputResults(result: DebateResult) {
  if (!outputPath && options.verbose) {
    const debate = await stateManager.getDebate(result.debateId);
    if (debate) {
      writeStderr('\nSummary (verbose)\n');
      debate.rounds.forEach((round) => {
        writeStderr(`Round ${round.roundNumber}\n`);
        const types = [PROPOSAL, CRITIQUE, REFINEMENT] as const;
        types.forEach((t) => {
          const items = round.contributions.filter((c) => c.type === t);
          if (items.length > 0) {
            writeStderr(`  ${t}:\n`);
            items.forEach((c) => {
              const firstLine = c.content.split('\n')[0];
              const tokens = c.metadata?.tokensUsed ?? 'N/A';
              const lat = c.metadata?.latencyMs ? `${c.metadata.latencyMs}ms` : 'N/A';
              writeStderr(`    [${c.agentRole}] ${firstLine}\n`);
              writeStderr(`      (latency=${lat}, tokens=${tokens})\n`);
            });
          }
        });
      });
      // ... more logic
    }
  }
}
```

**Solution:**
```typescript
// ✅ GOOD: Extract to focused function
function outputRoundSummary(round: DebateRound): void {
  writeStderr(`Round ${round.roundNumber}\n`);
  const types = [PROPOSAL, CRITIQUE, REFINEMENT] as const;
  types.forEach((t) => {
    const items = round.contributions.filter((c: Contribution) => c.type === t);
    if (items.length > 0) {
      writeStderr(`  ${t}:\n`);
      items.forEach((c: Contribution) => {
        const firstLine = c.content.split('\n')[0];
        const tokens = c.metadata?.tokensUsed ?? 'N/A';
        const lat = c.metadata?.latencyMs ? `${c.metadata.latencyMs}ms` : 'N/A';
        writeStderr(`    [${c.agentRole}] ${firstLine}\n`);
        writeStderr(`      (latency=${lat}, tokens=${tokens})\n`);
      });
    }
  });
}

// Usage: Clean and readable
async function outputResults(result: DebateResult) {
  if (!outputPath && options.verbose) {
    const debate = await stateManager.getDebate(result.debateId);
    if (debate) {
      writeStderr('\nSummary (verbose)\n');
      debate.rounds.forEach(outputRoundSummary); // Simple and clear
      // ... more logic
    }
  }
}
```

**Why It Matters:**
- **Readability**: Each function has single responsibility
- **Testability**: `outputRoundSummary` can be tested in isolation
- **Reusability**: Function can be used elsewhere if needed
- **Cognitive Load**: Easier to understand smaller, focused functions

### 5.6 Importing from Built Package Distribution

**Problem:** Importing symbols from the built package distribution (e.g., `'dialectic-core'`) instead of using relative source imports **within the same package**. This applies to both application code and test code.

**Code Smell:**
```typescript
// ❌ BAD: Importing from built package within the same package
// File: packages/core/src/utils/context-summarizer.spec.ts
import { LengthBasedSummarizer, LLMProvider, SummarizationConfig, SUMMARIZATION_METHODS, AGENT_ROLES, CompletionRequest, CompletionResponse, LLM_PROVIDERS } from 'dialectic-core';

// File: packages/core/src/utils/tracing-provider.spec.ts
import { TracingLLMProvider, LLMProvider, CompletionRequest, TracingContext } from 'dialectic-core';

// File: packages/core/src/core/agent.spec.ts
import { Agent, ToolRegistry, LLMProvider, DebateContext, AgentConfig, AGENT_ROLES } from 'dialectic-core';
```

**Solution:**
```typescript
// ✅ GOOD: Use relative source imports within the same package
// File: packages/core/src/utils/context-summarizer.spec.ts
import { LengthBasedSummarizer } from './context-summarizer';
import { LLMProvider, CompletionRequest, CompletionResponse } from '../providers/llm-provider';
import { SummarizationConfig, SUMMARIZATION_METHODS } from '../types/debate.types';
import { AGENT_ROLES, LLM_PROVIDERS } from '../types/agent.types';

// File: packages/core/src/utils/tracing-provider.spec.ts
import { TracingLLMProvider } from './tracing-provider';
import { LLMProvider, CompletionRequest } from '../providers/llm-provider';
import { TracingContext } from '../types/tracing.types';

// File: packages/core/src/core/agent.spec.ts
import { Agent } from './agent';
import { ToolRegistry } from '../tools/tool-registry';
import { LLMProvider } from '../providers/llm-provider';
import { DebateContext } from '../types/debate.types';
import { AgentConfig, AGENT_ROLES } from '../types/agent.types';
```

**Important Notes:**

**This rule applies WITHIN a package only:**
- ✅ **Within `packages/core/src/`**: Use relative imports like `'./context-summarizer'` or `'../types/debate.types'`
- ✅ **Within `packages/cli/src/`**: Use relative imports within that package
- ✅ **Cross-package imports**: Use package name imports like `'dialectic-core'` when importing from a different package
- ✅ **External packages**: Always use package name imports like `'fs'`, `'path'`, `'jest'`

**Applies to both application code and test code:**
- Application code: `packages/core/src/utils/context-summarizer.ts` should import from `'../providers/llm-provider'`, not `'dialectic-core'`
- Test code: `packages/core/src/utils/context-summarizer.spec.ts` should also import from `'../providers/llm-provider'`, not `'dialectic-core'`

**Why It Matters:**
- **No Build Required**: Tests can run without building the package first
- **Better IDE Support**: IDEs can provide better autocomplete and type checking with direct source imports
- **Faster Development**: No need to rebuild when making changes during development
- **Clearer Dependencies**: Relative imports make it immediately clear where symbols come from
- **Consistency**: Application code and test code follow the same import patterns

**When to Use Package Name Imports:**

**✅ Use package name imports (`'dialectic-core'`) when:**
- Importing from a **different package** (e.g., `packages/cli/src/` importing from `packages/core/`)
- Importing from **external packages** (e.g., `'fs'`, `'path'`, `'jest'`)

**❌ Don't use package name imports when:**
- Importing **within the same package** (e.g., `packages/core/src/utils/` importing from `packages/core/src/types/`)
- Both the importing file and the imported file are in the same package directory structure

---

## 6. Best Practices

### Consistent Naming
```typescript
// ❌ Inconsistent
const defaults = getDefaults();
const config = loadConfiguration();
const opts = parseOptions();

// ✅ Consistent
const defaults = loadDefaults();
const config = loadConfig();
const options = parseOptions();
```

### Single Responsibility
```typescript
// ❌ Function does too much
function processAndSaveAndNotify(data: Data) {
  const processed = transform(data);
  database.save(processed);
  email.send('Done!');
  return processed;
}

// ✅ Each function has one job
function processData(data: Data): ProcessedData {
  return transform(data);
}

async function saveData(data: ProcessedData): Promise<void> {
  await database.save(data);
}

async function notifyComplete(): Promise<void> {
  await email.send('Done!');
}
```

### Early Returns
```typescript
// ❌ Nested conditions
function validate(config: Config): boolean {
  if (config) {
    if (config.agents) {
      if (config.agents.length > 0) {
        return true;
      } else {
        return false;
      }
    } else {
      return false;
    }
  } else {
    return false;
  }
}

// ✅ Early returns
function validate(config: Config): boolean {
  if (!config) return false;
  if (!config.agents) return false;
  if (config.agents.length === 0) return false;
  return true;
}
```

---

## 7. Complete Example: Before and After

### Before - Needs cleanup:
```typescript
class PerformanceAgent extends Agent {
  async propose(problem: string, context: DebateContext): Promise<Proposal> {
    const system = this.config.systemPrompt || "You are a performance engineer...";
    const user = `Problem: ${problem}\n\nPropose solution...`;
    const { text, usage, latencyMs } = await this.callLLM(system, user);
    const metadata: any = { latencyMs, model: this.config.model };
    if (usage?.totalTokens != null) metadata.tokensUsed = usage.totalTokens;
    return { content: text, metadata };
  }

  async critique(proposal: Proposal, context: DebateContext): Promise<Critique> {
    const system = this.config.systemPrompt || "You are a performance engineer...";
    const user = `Review: ${proposal.content}`;
    const { text, usage, latencyMs } = await this.callLLM(system, user);
    const metadata: any = { latencyMs, model: this.config.model };
    if (usage?.totalTokens != null) metadata.tokensUsed = usage.totalTokens;
    return { content: text, metadata };
  }
}
```

### After - Clean and maintainable:
```typescript
// Constants at file level
const DEFAULT_PERFORMANCE_SYSTEM_PROMPT = `You are a performance engineer specializing in system optimization, profiling, and resource management.`;

/**
 * PerformanceAgent is an AI agent specializing in system performance optimization.
 * 
 * Focuses on latency, throughput, resource utilization, caching strategies,
 * and algorithmic complexity.
 *
 * Note: This class cannot be extended. Use the static `create` factory method to instantiate.
 */
export class PerformanceAgent extends Agent {
  /**
   * Private constructor to prevent direct instantiation and extension.
   * Use the static `create` method instead.
   */
  private constructor(config: AgentConfig, provider: LLMProvider) {
    super(config, provider);
  }

  /**
   * Factory method to create a new PerformanceAgent instance.
   */
  static create(config: AgentConfig, provider: LLMProvider): PerformanceAgent {
    return new PerformanceAgent(config, provider);
  }

  /**
   * Generates a performance-focused proposal for the given problem.
   * @param problem - The software/system design problem to solve.
   * @param context - The current debate context.
   * @returns A Promise resolving to a Proposal containing the solution and metadata.
   */
  async propose(problem: string, context: DebateContext): Promise<Proposal> {
    const system = this.config.systemPrompt || DEFAULT_PERFORMANCE_SYSTEM_PROMPT;
    const user = `Problem: ${problem}\n\nAs a performance engineer, propose a solution focusing on latency, throughput, and resource efficiency.`;
    return this.proposeImpl(context, system, user);
  }

  /**
   * Critiques a given proposal from a performance engineering perspective.
   * @param proposal - The proposal to critique.
   * @param context - The current debate context.
   * @returns A Promise resolving to a Critique containing the review and metadata.
   */
  async critique(proposal: Proposal, context: DebateContext): Promise<Critique> {
    const system = this.config.systemPrompt || DEFAULT_PERFORMANCE_SYSTEM_PROMPT;
    const user = `Review this proposal as a performance engineer. Identify bottlenecks and improvements.\n\nProposal:\n${proposal.content}`;
    return this.critiqueImpl(proposal, context, system, user);
  }
}
```

---

## 8. Quick Reference

| Problem | Solution | Example |
|---------|----------|---------|
| Duplicate method logic | Template method pattern | `proposeImpl()` in base class |
| Magic number `3` | Named constant | `DEFAULT_ROUNDS = 3` |
| String `"architect"` | Constant object | `AGENT_ROLES.ARCHITECT` |
| String used multiple times in one function | Function-level constant | `const EXPECTED_REASONING = 'Good'` |
| Long complex function | Extract helper functions | `debateConfigFromSysConfig()` |
| Unclear technical choice | Inline comment | `// Use stderr.write for unbuffered output` |
| Public function | JSDoc with @param/@returns | See examples above |
| Repeated pattern 3+ times | Extract to helper function | `createAgentWithPromptResolution()` |

---

## 9. Checklist for Code Cleanup

When reviewing code, check:

- [ ] **No duplicate logic** - Extract common patterns to base classes or utility functions
- [ ] **No magic numbers** - All literal numbers replaced with named constants
- [ ] **No hardcoded strings** - Especially for types, roles, statuses - use constants
- [ ] **All public APIs documented** - JSDoc for functions, classes, complex methods
- [ ] **Non-obvious choices explained** - Inline comments for "why" not "what"
- [ ] **Constants properly scoped** - Function-level for single-function use, file-level for local, exported for shared
- [ ] **Template methods marked @final** - When they shouldn't be overridden
- [ ] **Function extraction** - Large functions broken into smaller, focused ones
- [ ] **Separation of concerns** - Each function has a single, clear purpose
- [ ] **Proper stdout/stderr usage** - Results to stdout, diagnostics to stderr
- [ ] **No redundant calls** - Functions called once, results reused
- [ ] **No unnecessary exports** - Internal constants accessed through methods
- [ ] **No inline type repetition** - Types defined once, reused everywhere
- [ ] **No unnecessary type casts** - Proper typing instead of `as any`
- [ ] **Relative imports within package** - Use relative paths, not package name imports

---

## Summary

Good code is:
- **DRY**: Don't Repeat Yourself - extract common patterns
- **Type-safe**: Let the compiler help you - avoid unnecessary type casts
- **Clear**: Easy to read and understand - self-documenting with good names
- **Focused**: Each function does one thing well - single responsibility
- **Consistent**: Follows established patterns throughout the codebase

**Remember:** If you copy-paste code, you're doing it wrong. Extract it to a reusable function or class.